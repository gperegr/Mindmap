<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MindMap</title>
    <script src="assets/tailwind.js"></script>
    <link rel="stylesheet" href="assets/css/all.min.css">
    <style>
        :root {
            /* Light Theme Defaults */
            --bg-color: #f2f2f7;
            --grid-color: #c7c7cc;
            --glass-bg: rgba(255, 255, 255, 0.65);
            --glass-border: rgba(255, 255, 255, 0.4);
            --panel-bg: rgba(245, 245, 247, 0.85);
            --text-color: #1d1d1f;
            --node-bg: rgba(255, 255, 255, 0.65);
            --line-color: #8e8e93;
            --line-active: #007aff;
            --shadow-color: rgba(31, 38, 135, 0.07);
        }

        body.dark-mode {
            /* Dark Theme Overrides */
            --bg-color: #101010; /* Deep black/gray */
            --grid-color: #3a3a3c;
            --glass-bg: rgba(40, 40, 40, 0.65);
            --glass-border: rgba(255, 255, 255, 0.1);
            --panel-bg: rgba(30, 30, 30, 0.85);
            --text-color: #f5f5f7;
            --node-bg: rgba(50, 50, 50, 0.65);
            --line-color: #636366;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        /* System Fonts & Base */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Blueprint Grid Pattern */
        #canvas-bg {
            background-size: 20px 20px;
            background-image: radial-gradient(circle, var(--grid-color) 1.5px, transparent 1.5px);
            width: 3000px;
            height: 3000px;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
            opacity: 1;
            transition: opacity 0.3s, background-image 0.3s;
        }

        /* Glassmorphism Classes */
        .glass {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px 0 var(--shadow-color);
            transition: background 0.3s, border-color 0.3s;
        }

        .glass-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: 1px solid var(--glass-border);
            transition: background 0.3s, border-color 0.3s;
        }

        /* Node Styling */
        .node {
            position: absolute;
            display: flex;
            align-items: center; /* Vertically center content */
            justify-content: center; /* Horizontally center content */
            min-width: 100px;
            min-height: 60px;
            padding: 10px;
            font-size: 15px;
            color: var(--text-color);
            background: var(--node-bg);
            cursor: grab;
            transition: box-shadow 0.2s ease, transform 0.1s, background 0.3s, color 0.3s;
            z-index: 10;
            text-align: center;
            outline: none;
        }

        .node-content {
            width: 100%;
            /* Removed height: 100% to allow parent .node to center it vertically */
            min-width: 50px;
            outline: none;
            cursor: text;
            pointer-events: auto;
        }

        .node:active {
            cursor: grabbing;
            transform: scale(1.02);
        }

        .node.selected {
            box-shadow: 0 0 0 2px #007aff, 0 8px 20px rgba(0,0,0,0.15);
            z-index: 20;
        }

        /* Shape Variants */
        .shape-rect { border-radius: 16px; }
        .shape-circle { border-radius: 50%; aspect-ratio: 1/1; min-height: 100px; padding: 25px; }
        .shape-capsule { border-radius: 9999px; }
        .shape-text { 
            background: var(--bg-color) !important; 
            border: none !important; 
            box-shadow: none !important; 
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            min-width: 60px;
            min-height: 40px;
        }

        /* Connection Anchor */
        .connector-handle {
            width: 16px;
            height: 16px;
            background-color: #34c759;
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
            cursor: crosshair;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 30;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .connector-handle:hover {
            transform: translateY(-50%) scale(1.2);
        }

        .node:hover .connector-handle, 
        .node.selected .connector-handle {
            opacity: 1;
        }

        /* SVG Lines */
        #connections-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 3000px;
            height: 3000px;
            z-index: 1;
            pointer-events: none;
        }
        
        path.connection {
            fill: none;
            stroke: var(--line-color);
            stroke-width: 2;
            stroke-linecap: round;
            transition: stroke 0.2s, stroke-width 0.2s;
            pointer-events: visibleStroke;
            cursor: pointer;
        }

        path.connection:hover {
            stroke: var(--line-active);
            stroke-opacity: 0.5;
        }

        path.connection.selected {
            stroke: var(--line-active);
            stroke-width: 4;
            filter: drop-shadow(0 0 3px rgba(0, 122, 255, 0.5));
        }

        /* Zoom Slider Styles */
        input[type=range][orient=vertical] {
            writing-mode: bt-lr; 
            -webkit-appearance: slider-vertical;
            width: 8px;
            height: 150px;
            padding: 0 5px;
        }
        
        .slider-container {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            height: 200px;
            width: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            z-index: 50;
            padding: 10px 0;
            border-radius: 20px;
        }

        .range-wrapper {
            height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .vertical-range {
            transform: rotate(-90deg);
            width: 150px;
            height: 20px;
            cursor: pointer;
        }
        
        /* Utility for sidebar icons */
        .sidebar-icon {
            color: #8e8e93; 
        }
        .dark-mode .sidebar-icon {
            color: #aeaeb2;
        }
        
        /* Draggable visual tweak for dark mode */
        .draggable-source .visual {
            background: white;
            border-color: #e5e7eb;
        }
        .dark-mode .draggable-source .visual {
            background: #2c2c2e;
            border-color: #48484a;
        }
        .dark-mode .draggable-source .inner-shape {
            border-color: #8e8e93;
        }

        /* --- Custom Modal & Toast Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-box {
            background: var(--panel-bg);
            border: 1px solid var(--glass-border);
            padding: 24px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            max-width: 320px;
            width: 100%;
            text-align: center;
            transform: scale(0.95);
            transition: transform 0.2s;
        }
        .modal-overlay.active .modal-box {
            transform: scale(1);
        }

        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: rgba(30, 30, 30, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 14px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 200;
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
        }
        .toast.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Color Picker Styles */
        .color-circle {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid white;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .color-circle:hover {
            transform: scale(1.2);
            box-shadow: 0 0 8px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body class="w-full h-screen overflow-hidden">

    <!-- Custom Modal -->
    <div id="modal-overlay" class="modal-overlay">
        <div class="modal-box glass">
            <h3 class="text-lg font-semibold mb-2" id="modal-title">Confirm</h3>
            <p class="text-sm text-gray-500 mb-6" id="modal-message">Are you sure?</p>
            <div class="flex gap-2 justify-center">
                <button onclick="closeModal()" class="px-4 py-2 rounded-full text-sm font-medium text-gray-500 hover:bg-gray-200/50 transition">Cancel</button>
                <button id="modal-confirm-btn" class="px-4 py-2 rounded-full text-sm font-medium bg-blue-500 text-white hover:bg-blue-600 transition shadow-lg shadow-blue-500/30">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Custom Toast -->
    <div id="toast" class="toast">Action Successful</div>

    <!-- Hidden File Input for Loading -->
    <input type="file" id="file-input" style="display: none;" accept=".mindmap">

    <!-- Main Container -->
    <div class="relative w-full h-full flex">

        <!-- Sidebar (Palette) -->
        <div id="sidebar" class="w-24 md:w-32 h-full glass-panel flex flex-col items-center pt-8 z-50 shrink-0 relative shadow-xl transition-colors duration-300">
            <div class="mb-6 font-semibold text-xs text-gray-500 uppercase tracking-widest">Library</div>
            
            <!-- Draggable Template: Rectangle -->
            <div class="draggable-source mb-6 cursor-grab active:cursor-grabbing transition-transform hover:scale-105" draggable="true" data-shape="shape-rect">
                <div class="visual w-14 h-14 border rounded-2xl shadow-sm flex items-center justify-center transition-colors duration-300">
                    <div class="inner-shape w-8 h-8 border-2 border-gray-400 rounded-md"></div>
                </div>
                <div class="text-[10px] text-center mt-2 text-gray-500">Card</div>
            </div>

            <!-- Draggable Template: Circle -->
            <div class="draggable-source mb-6 cursor-grab active:cursor-grabbing transition-transform hover:scale-105" draggable="true" data-shape="shape-circle">
                <div class="visual w-14 h-14 border rounded-2xl shadow-sm flex items-center justify-center transition-colors duration-300">
                    <div class="inner-shape w-8 h-8 border-2 border-gray-400 rounded-full"></div>
                </div>
                <div class="text-[10px] text-center mt-2 text-gray-500">Circle</div>
            </div>

            <!-- Draggable Template: Capsule -->
            <div class="draggable-source mb-6 cursor-grab active:cursor-grabbing transition-transform hover:scale-105" draggable="true" data-shape="shape-capsule">
                <div class="visual w-14 h-14 border rounded-2xl shadow-sm flex items-center justify-center transition-colors duration-300">
                    <div class="inner-shape w-10 h-6 border-2 border-gray-400 rounded-full"></div>
                </div>
                <div class="text-[10px] text-center mt-2 text-gray-500">Capsule</div>
            </div>

            <!-- Draggable Template: Text -->
            <div class="draggable-source mb-6 cursor-grab active:cursor-grabbing transition-transform hover:scale-105" draggable="true" data-shape="shape-text">
                <div class="visual w-14 h-14 border rounded-2xl shadow-sm flex items-center justify-center transition-colors duration-300">
                    <span class="text-xl font-bold text-gray-400">T</span>
                </div>
                <div class="text-[10px] text-center mt-2 text-gray-500">Text</div>
            </div>
            
            <div class="absolute bottom-8 text-[10px] text-gray-400 text-center px-2">
                Drag to board.<br>Type to edit.<br>Select to delete.
            </div>
        </div>

        <!-- Canvas Container (Scroll View) -->
        <div id="canvas-container" class="flex-1 relative overflow-scroll relative transition-colors duration-300">
            
            <!-- Zoom Sizer (Ensures scrollbars work with zoom) -->
            <div id="canvas-sizer" style="width: 3000px; height: 3000px;">
                
                <!-- The Infinite Canvas Area (Scaled) -->
                <div id="canvas-area" class="relative origin-top-left" style="width: 3000px; height: 3000px;">
                    
                    <!-- Background Dots -->
                    <div id="canvas-bg"></div>
                    
                    <!-- SVG Layer for Lines -->
                    <svg id="connections-layer">
                        <!-- Dynamic paths go here -->
                    </svg>

                    <!-- Node Toolbar (Color Picker) -->
                    <div id="node-toolbar" class="absolute hidden flex gap-2 p-2 glass rounded-full z-50 items-center justify-center transition-opacity duration-200" style="height: 46px;">
                        <!-- Default (Theme) -->
                        <div class="color-circle" style="background: linear-gradient(135deg, #e0e0e0 50%, #333 50%);" onclick="setNodeColor(null)" title="Default Theme"></div>
                        <!-- Red -->
                        <div class="color-circle" style="background-color: #D53E4F;" onclick="setNodeColor('#D53E4F')"></div>
                        <!-- Yellow -->
                        <div class="color-circle" style="background-color: #FEE08B;" onclick="setNodeColor('#FEE08B')"></div>
                        <!-- Green -->
                        <div class="color-circle" style="background-color: #99D594;" onclick="setNodeColor('#99D594')"></div>
                        <!-- Blue -->
                        <div class="color-circle" style="background-color: #3288BD;" onclick="setNodeColor('#3288BD')"></div>
                    </div>

                    <!-- Temporary Dragging Line -->
                    <svg id="drag-line-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none z-40" style="display:none;">
                        <path id="drag-line" d="" stroke="#007aff" stroke-width="2" stroke-dasharray="5,5" fill="none" />
                    </svg>

                    <!-- Nodes go here via JS -->
                </div>
            </div>
        </div>

        <!-- Floating Controls (Top Right) -->
        <div class="absolute top-4 right-4 z-50 flex gap-2 items-center">
            <!-- Theme Toggle -->
            <button id="btn-theme" class="glass w-10 h-10 flex items-center justify-center rounded-full text-gray-500 hover:text-yellow-500 hover:bg-white transition" title="Toggle Dark Mode">
                <i class="fas fa-moon"></i>
            </button>
            
            <!-- Grid Toggle -->
            <button id="btn-grid" class="glass w-10 h-10 flex items-center justify-center rounded-full text-gray-500 hover:text-purple-500 hover:bg-white transition" title="Toggle Grid">
                <i class="fas fa-border-all"></i>
            </button>

            <!-- Divider -->
            <div class="w-px h-10 bg-gray-300/50 mx-1"></div>

            <!-- Save/Load -->
            <button id="btn-save" class="glass w-10 h-10 flex items-center justify-center rounded-full text-gray-500 hover:text-blue-500 hover:bg-white transition" title="Download File">
                <i class="fas fa-download"></i>
            </button>
            <button id="btn-load" class="glass w-10 h-10 flex items-center justify-center rounded-full text-gray-500 hover:text-green-500 hover:bg-white transition" title="Open File">
                <i class="fas fa-folder-open"></i>
            </button>

            <!-- Divider -->
            <div class="w-px h-10 bg-gray-300/50 mx-1"></div>

            <!-- View Controls -->
            <button id="btn-fit" class="glass w-10 h-10 flex items-center justify-center rounded-full text-gray-500 hover:text-blue-500 hover:bg-white transition" title="View Everything">
                <i class="fas fa-compress-arrows-alt"></i>
            </button>
            <button id="btn-delete" class="glass w-10 h-10 flex items-center justify-center rounded-full text-gray-500 hover:text-red-500 hover:bg-white transition" title="Delete Selected (Del)">
                <i class="fas fa-trash"></i>
            </button>
            <button id="btn-clear" class="glass px-4 py-2 rounded-full text-sm font-medium hover:bg-white/80 transition text-red-500">
                Clear All
            </button>

            <!-- Info Icon with Tooltip -->
            <div class="relative group">
                <button class="glass w-10 h-10 flex items-center justify-center rounded-full text-gray-500 hover:text-blue-500 hover:bg-white transition cursor-help">
                    <i class="fas fa-info-circle"></i>
                </button>
                <div class="absolute right-0 top-12 w-max px-3 py-1.5 bg-gray-800 text-white text-xs rounded-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none shadow-lg z-50 backdrop-blur-sm">
                    Version 1.0 | Developed by Gabriel Peregrino
                </div>
            </div>
        </div>

        <!-- Zoom Slider Sidebar -->
        <div class="slider-container glass">
            <i class="fas fa-plus text-xs text-gray-400 mb-2"></i>
            <div class="range-wrapper">
                <input type="range" id="zoom-slider" min="0.2" max="2.0" step="0.1" value="1.0" class="vertical-range">
            </div>
            <i class="fas fa-minus text-xs text-gray-400 mt-2"></i>
        </div>
    </div>

    <script>
        // --- UI Utilities (Modal & Toast) ---
        const modalOverlay = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const toastEl = document.getElementById('toast');
        let toastTimeout;

        function showToast(msg) {
            toastEl.innerText = msg;
            toastEl.classList.add('active');
            clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => {
                toastEl.classList.remove('active');
            }, 3000);
        }

        let confirmCallback = null;

        function showConfirm(title, message, onYes, isDestructive = false) {
            modalTitle.innerText = title;
            modalMessage.innerText = message;
            
            // Style button based on action type
            if(isDestructive) {
                modalConfirmBtn.className = "px-4 py-2 rounded-full text-sm font-medium bg-red-500 text-white hover:bg-red-600 transition shadow-lg shadow-red-500/30";
            } else {
                modalConfirmBtn.className = "px-4 py-2 rounded-full text-sm font-medium bg-blue-500 text-white hover:bg-blue-600 transition shadow-lg shadow-blue-500/30";
            }

            confirmCallback = onYes;
            modalOverlay.classList.add('active');
        }

        function closeModal() {
            modalOverlay.classList.remove('active');
            confirmCallback = null;
        }

        modalConfirmBtn.addEventListener('click', () => {
            if (confirmCallback) confirmCallback();
            closeModal();
        });


        // --- State Management ---
        const GRID_SIZE = 20;
        const CANVAS_SIZE = 3000;
        let nodes = [];
        let connections = [];
        let selectedNodeId = null;
        let selectedConnectionId = null;
        let isDraggingNode = false;
        let isConnecting = false;
        let dragOffset = { x: 0, y: 0 };
        let draggedNodeId = null;
        let connectionStartNodeId = null;
        let currentZoom = 1.0;
        let isDarkMode = false;

        // --- DOM Elements ---
        const canvasContainer = document.getElementById('canvas-container');
        const canvasSizer = document.getElementById('canvas-sizer');
        const canvasArea = document.getElementById('canvas-area');
        const sidebarItems = document.querySelectorAll('.draggable-source');
        const svgLayer = document.getElementById('connections-layer');
        const dragLineLayer = document.getElementById('drag-line-layer');
        const dragLinePath = document.getElementById('drag-line');
        const btnDelete = document.getElementById('btn-delete');
        const btnClear = document.getElementById('btn-clear');
        const btnFit = document.getElementById('btn-fit');
        const btnSave = document.getElementById('btn-save');
        const btnLoad = document.getElementById('btn-load');
        const btnTheme = document.getElementById('btn-theme');
        const btnGrid = document.getElementById('btn-grid');
        const zoomSlider = document.getElementById('zoom-slider');
        const fileInput = document.getElementById('file-input');
        const nodeToolbar = document.getElementById('node-toolbar');

        // --- Initialization ---
        window.onload = () => {
            canvasContainer.scrollLeft = (CANVAS_SIZE - canvasContainer.clientWidth) / 2;
            canvasContainer.scrollTop = (CANVAS_SIZE - canvasContainer.clientHeight) / 2;
            
            // Auto-load theme preference
            if(localStorage.getItem('mindmap_theme') === 'dark') {
                toggleTheme();
            }
        };

        // --- Drag & Drop from Sidebar ---
        sidebarItems.forEach(item => {
            item.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('shape', item.dataset.shape);
            });
        });

        canvasContainer.addEventListener('dragover', (e) => e.preventDefault());
        
        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const shapeType = e.dataTransfer.getData('shape');
            
            const rect = canvasArea.getBoundingClientRect();
            const clientX = e.clientX;
            const clientY = e.clientY;
            
            const rawX = (clientX - rect.left) / currentZoom;
            const rawY = (clientY - rect.top) / currentZoom;

            const x = Math.round(rawX / GRID_SIZE) * GRID_SIZE;
            const y = Math.round(rawY / GRID_SIZE) * GRID_SIZE;
            createNode(x, y, shapeType);
        });

        // --- Zoom Logic ---
        function setZoom(zoomLevel) {
            const oldZoom = currentZoom;
            const newZoom = parseFloat(zoomLevel);
            
            // 1. Calculate Target Center (Unscaled Coords)
            // If a node is selected, we want its center. 
            // If not, we want the current viewport center.
            let targetX, targetY;

            if (selectedNodeId) {
                const node = nodes.find(n => n.id === selectedNodeId);
                if (node) {
                    const w = node.el.offsetWidth;
                    const h = node.el.offsetHeight;
                    targetX = node.x + w / 2;
                    targetY = node.y + h / 2;
                }
            } 
            
            if (!targetX) {
                // Default: Keep center of viewport centered
                const rect = canvasContainer.getBoundingClientRect();
                // Center relative to the container's scroll view (scaled pixels)
                const centerX = canvasContainer.scrollLeft + rect.width / 2;
                const centerY = canvasContainer.scrollTop + rect.height / 2;
                
                // Convert to unscaled canvas coords
                targetX = centerX / oldZoom;
                targetY = centerY / oldZoom;
            }

            // 2. Apply Zoom
            currentZoom = newZoom;
            canvasArea.style.transform = `scale(${currentZoom})`;
            canvasSizer.style.width = `${CANVAS_SIZE * currentZoom}px`;
            canvasSizer.style.height = `${CANVAS_SIZE * currentZoom}px`;
            zoomSlider.value = currentZoom;

            // 3. Scroll to new position to align Target Center with Viewport Center
            // Target Pixel Position = target * newZoom
            // Viewport Center = viewportSize / 2
            // ScrollPos = TargetPixel - ViewportCenter
            const viewportW = canvasContainer.clientWidth;
            const viewportH = canvasContainer.clientHeight;
            
            canvasContainer.scrollLeft = (targetX * newZoom) - (viewportW / 2);
            canvasContainer.scrollTop = (targetY * newZoom) - (viewportH / 2);
        }

        zoomSlider.addEventListener('input', (e) => setZoom(e.target.value));

        btnFit.addEventListener('click', () => {
            if (nodes.length === 0) {
                setZoom(1);
                return;
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(n => {
                minX = Math.min(minX, n.x);
                minY = Math.min(minY, n.y);
                const w = n.el.offsetWidth || 150; 
                const h = n.el.offsetHeight || 100;
                maxX = Math.max(maxX, n.x + w);
                maxY = Math.max(maxY, n.y + h);
            });

            const margin = 100;
            const contentW = maxX - minX + (margin * 2);
            const contentH = maxY - minY + (margin * 2);
            
            const viewportW = canvasContainer.clientWidth;
            const viewportH = canvasContainer.clientHeight;

            const scaleX = viewportW / contentW;
            const scaleY = viewportH / contentH;
            let newZoom = Math.min(scaleX, scaleY);
            newZoom = Math.max(0.2, Math.min(newZoom, 2.0));

            // Apply zoom
            currentZoom = newZoom;
            canvasArea.style.transform = `scale(${currentZoom})`;
            canvasSizer.style.width = `${CANVAS_SIZE * currentZoom}px`;
            canvasSizer.style.height = `${CANVAS_SIZE * currentZoom}px`;
            zoomSlider.value = currentZoom;

            // Center View
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            canvasContainer.scrollLeft = (centerX * newZoom) - (viewportW / 2);
            canvasContainer.scrollTop = (centerY * newZoom) - (viewportH / 2);
        });

        // --- Node Creation Logic ---
        function generateId() {
            return 'node-' + Math.random().toString(36).substr(2, 9);
        }

        function getContrastColor(hex) {
            const mapping = {
                '#D53E4F': '#4a0d13', // Dark Red
                '#FEE08B': '#544a05', // Dark Yellow/Brown
                '#99D594': '#1e451d', // Dark Green
                '#3288BD': '#0b2d42'  // Dark Blue
            };
            return mapping[hex] || null;
        }

        function createNode(x, y, shapeType, existingId = null, existingText = null, existingColor = null) {
            const id = existingId || generateId();
            const nodeEl = document.createElement('div');
            
            nodeEl.tabIndex = 0; 
            nodeEl.className = `node glass ${shapeType}`;
            nodeEl.id = id;
            nodeEl.style.left = `${x}px`;
            nodeEl.style.top = `${y}px`;

            if (existingColor) {
                nodeEl.style.backgroundColor = existingColor;
                const textColor = getContrastColor(existingColor);
                if (textColor) nodeEl.style.color = textColor;
            }
            
            const contentEl = document.createElement('div');
            contentEl.className = 'node-content';
            contentEl.contentEditable = "true";
            contentEl.innerText = existingText || "New Idea";
            contentEl.spellcheck = false;
            nodeEl.appendChild(contentEl);

            const handle = document.createElement('div');
            handle.className = 'connector-handle';
            handle.contentEditable = "false";
            nodeEl.appendChild(handle);

            contentEl.addEventListener('focus', function() {
                selectNode(id);
                if (this.innerText === "New Idea") {
                    this.innerText = "";
                }
            });

            contentEl.addEventListener('blur', function() {
                if (this.innerText.trim() === "") {
                    this.innerText = "New Idea";
                }
            });

            contentEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    contentEl.blur(); 
                    nodeEl.focus(); 
                }
            });

            nodeEl.addEventListener('mousedown', (e) => {
                if (e.target === handle) return; 
                
                selectNode(id);
                selectConnection(null); 

                if (e.target === nodeEl) {
                    e.preventDefault(); 
                    nodeEl.focus();
                    isDraggingNode = true;
                    draggedNodeId = id;
                    
                    const rect = nodeEl.getBoundingClientRect();
                    dragOffset.x = (e.clientX - rect.left) / currentZoom;
                    dragOffset.y = (e.clientY - rect.top) / currentZoom;
                }
            });

            contentEl.addEventListener('input', () => {
                updateConnections();
            });

            canvasArea.appendChild(nodeEl);
            nodes.push({ id, el: nodeEl, x, y, type: shapeType, color: existingColor });
            
            if(!existingId) selectNode(id);
            
            handle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                startConnectionDrag(id, e);
            });
        }

        // --- Selection Logic ---
        function selectNode(id) {
            document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
            selectedNodeId = id;
            if(id) {
                const el = document.getElementById(id);
                if(el) el.classList.add('selected');
                
                // Show and position toolbar
                updateToolbarPosition(id);
                
                selectedConnectionId = null; 
                document.querySelectorAll('.connection').forEach(c => c.classList.remove('selected'));
            } else {
                nodeToolbar.style.display = 'none';
            }
        }

        function updateToolbarPosition(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (node.type === 'shape-text') {
                nodeToolbar.style.display = 'none';
                return;
            }

            // Position above the node
            const toolbarHeight = 60; 
            const nodeWidth = node.el.offsetWidth;
            
            // Center toolbar horizontally relative to node
            // Place it slightly above the node
            nodeToolbar.style.display = 'flex';
            
            // We need to wait for display:flex to apply to get correct width, 
            // but since it's fixed width content, we can approximate or use requestAnimationFrame
            requestAnimationFrame(() => {
                const toolbarWidth = nodeToolbar.offsetWidth;
                nodeToolbar.style.left = (node.x + (nodeWidth / 2) - (toolbarWidth / 2)) + 'px';
                nodeToolbar.style.top = (node.y - toolbarHeight) + 'px';
            });
        }

        function setNodeColor(color) {
            if (!selectedNodeId) return;
            const nodeObj = nodes.find(n => n.id === selectedNodeId);
            if (nodeObj) {
                nodeObj.color = color;
                if (color) {
                    nodeObj.el.style.backgroundColor = color;
                    const textColor = getContrastColor(color);
                    if (textColor) nodeObj.el.style.color = textColor;
                } else {
                    nodeObj.el.style.backgroundColor = ''; // Revert to CSS class
                    nodeObj.el.style.color = ''; // Revert to CSS class
                }
            }
        }

        function selectConnection(id) {
            document.querySelectorAll('.connection').forEach(c => c.classList.remove('selected'));
            selectedConnectionId = id;
            if (id) {
                const el = document.getElementById(id);
                if (el) el.classList.add('selected');
                selectedNodeId = null; 
                document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
            }
        }

        // --- Interaction Handlers ---
        document.addEventListener('mousemove', (e) => {
            if (isDraggingNode && draggedNodeId) {
                const nodeObj = nodes.find(n => n.id === draggedNodeId);
                if (!nodeObj) return;

                const containerRect = canvasArea.getBoundingClientRect();
                
                const rawX = (e.clientX - containerRect.left) / currentZoom - dragOffset.x;
                const rawY = (e.clientY - containerRect.top) / currentZoom - dragOffset.y;

                const snappedX = Math.round(rawX / GRID_SIZE) * GRID_SIZE;
                const snappedY = Math.round(rawY / GRID_SIZE) * GRID_SIZE;

                nodeObj.el.style.left = `${snappedX}px`;
                nodeObj.el.style.top = `${snappedY}px`;
                nodeObj.x = snappedX;
                nodeObj.y = snappedY;
                
                updateToolbarPosition(draggedNodeId);

                updateConnections();
            } else if (isConnecting) {
                updateDragLine(e);
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (isDraggingNode) {
                isDraggingNode = false;
                draggedNodeId = null;
            }

            if (isConnecting) {
                const targetEl = document.elementFromPoint(e.clientX, e.clientY);
                const targetNode = targetEl ? targetEl.closest('.node') : null;

                if (targetNode && targetNode.id !== connectionStartNodeId) {
                    createConnection(connectionStartNodeId, targetNode.id);
                }
                stopConnectionDrag();
            }
        });

        canvasArea.addEventListener('mousedown', (e) => {
            if (e.target === canvasArea || e.target.id === 'canvas-bg') {
                selectNode(null);
                selectConnection(null);
            }
        });

        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const direction = e.deltaY > 0 ? -1 : 1;
            let newZoom = currentZoom + (direction * 0.1);
            // Clamp based on slider limits (0.2 to 2.0)
            newZoom = Math.max(0.2, Math.min(newZoom, 2.0));
            setZoom(newZoom);
        }, { passive: false });

        // --- Actions ---

        function deleteSelected() {
            if (selectedNodeId) {
                const nodeObj = nodes.find(n => n.id === selectedNodeId);
                if (nodeObj) {
                    nodeObj.el.remove();
                    const toRemove = connections.filter(c => c.from === selectedNodeId || c.to === selectedNodeId);
                    toRemove.forEach(c => c.el.remove());
                    
                    connections = connections.filter(c => c.from !== selectedNodeId && c.to !== selectedNodeId);
                    nodes = nodes.filter(n => n.id !== selectedNodeId);
                    nodeToolbar.style.display = 'none';
                    
                    selectedNodeId = null;
                }
            } else if (selectedConnectionId) {
                const connObj = connections.find(c => c.id === selectedConnectionId);
                if (connObj) {
                    connObj.el.remove();
                    connections = connections.filter(c => c.id !== selectedConnectionId);
                    selectedConnectionId = null;
                }
            }
        }

        // IMPROVED: Fixed Clear Logic with Custom Modal
        btnClear.addEventListener('click', () => {
            if(nodes.length === 0) {
                 showToast("Board is already empty");
                 return;
            }
            showConfirm(
                "Clear Board?", 
                "Are you sure you want to delete everything? This cannot be undone.", 
                () => {
                    nodes = [];
                    connections = [];
                    selectedNodeId = null;
                    selectedConnectionId = null;
                    nodeToolbar.style.display = 'none';
                    
                    const domNodes = document.querySelectorAll('.node');
                    domNodes.forEach(n => n.remove());
                    
                    const domLines = document.querySelectorAll('.connection');
                    domLines.forEach(l => l.remove());
                    
                    showToast("Board Cleared");
                },
                true // Destructive
            );
        });

        // Toggle Theme
        function toggleTheme() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode');
            const icon = btnTheme.querySelector('i');
            if(isDarkMode) {
                icon.className = 'fas fa-sun';
                localStorage.setItem('mindmap_theme', 'dark');
            } else {
                icon.className = 'fas fa-moon';
                localStorage.setItem('mindmap_theme', 'light');
            }
        }
        btnTheme.addEventListener('click', toggleTheme);

        // Toggle Grid
        let isGridVisible = true;
        btnGrid.addEventListener('click', () => {
            isGridVisible = !isGridVisible;
            document.getElementById('canvas-bg').style.opacity = isGridVisible ? '1' : '0';
            btnGrid.querySelector('i').className = isGridVisible ? 'fas fa-border-all' : 'fas fa-border-none';
        });

        // Save Logic (Download JSON)
        btnSave.addEventListener('click', () => {
            if (nodes.length === 0) {
                showToast("Nothing to save");
                return;
            }

            const data = {
                nodes: nodes.map(n => ({
                    id: n.id,
                    x: n.x,
                    y: n.y,
                    type: n.type,
                    text: n.el.querySelector('.node-content').innerText,
                    color: n.color // Save color
                })),
                connections: connections.map(c => ({
                    id: c.id,
                    from: c.from,
                    to: c.to
                }))
            };
            
            const jsonStr = JSON.stringify(data, null, 2);

            // Check if running inside Python (pywebview)
            if (window.pywebview) {
                window.pywebview.api.save_content(jsonStr).then((response) => {
                    if (response === "success") showToast("File Saved Successfully");
                    else if (response !== "cancelled") showToast("Error Saving File");
                });
            } else {
                // Fallback to Browser Download
                try {
                    const blob = new Blob([jsonStr], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    const dateStr = new Date().toISOString().slice(0,10);
                    a.download = `mindmap_${dateStr}.mindmap`;
                    
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showToast("File Downloaded");
                } catch(e) {
                    console.error(e);
                    showToast("Error Generating File");
                }
            }
        });

        // Load Logic (Open File Dialog)
        btnLoad.addEventListener('click', () => {
            // Check if running inside Python (pywebview)
            if (window.pywebview) {
                if (nodes.length > 0) {
                    showConfirm("Load File?", "Current work will be overwritten.", () => loadFromPython());
                } else {
                    loadFromPython();
                }
                return;
            }

            // Use existing confirm logic if board has items
            if (nodes.length > 0) {
                showConfirm(
                    "Load File?",
                    "Current work will be overwritten.",
                    () => {
                        fileInput.click();
                    }
                );
            } else {
                fileInput.click();
            }
        });

        // Helper to handle Python loading
        function loadFromPython() {
            window.pywebview.api.load_content().then((content) => {
                if (content) {
                    processLoadedData(content);
                }
            });
        }

        // Extracted logic to process JSON data
        function processLoadedData(jsonString) {
            try {
                const data = JSON.parse(jsonString);
                if (!data.nodes || !data.connections) throw new Error("Invalid format");

                nodes.forEach(n => n.el.remove());
                connections.forEach(c => c.el.remove());
                nodes = [];
                connections = [];
                
                data.nodes.forEach(n => createNode(n.x, n.y, n.type, n.id, n.text, n.color));
                data.connections.forEach(c => createConnection(c.from, c.to, c.id));
                
                showToast("Map Loaded Successfully");
            } catch(e) {
                console.error(e);
                showToast("Error: Invalid MindMap File");
            }
        }

        // Handle File Selection
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                processLoadedData(event.target.result);
            };
            
            reader.readAsText(file);
            // Reset input so same file can be selected again if needed
            e.target.value = '';
        });

        btnDelete.addEventListener('click', deleteSelected);

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                const activeEl = document.activeElement;
                const isEditingText = activeEl.classList.contains('node-content');
                if (!isEditingText) {
                    if (selectedNodeId || selectedConnectionId) {
                        e.preventDefault(); 
                        deleteSelected();
                    }
                }
            }
        });

        // --- Connection Logic ---
        function startConnectionDrag(sourceId, e) {
            isConnecting = true;
            connectionStartNodeId = sourceId;
            dragLineLayer.style.display = 'block';
            updateDragLine(e);
        }

        function updateDragLine(e) {
            const sourceNode = nodes.find(n => n.id === connectionStartNodeId);
            if (!sourceNode) return;

            const w = sourceNode.el.offsetWidth;
            const h = sourceNode.el.offsetHeight;
            const x1 = sourceNode.x + w/2;
            const y1 = sourceNode.y + h/2;

            const rect = canvasArea.getBoundingClientRect();
            const x2 = (e.clientX - rect.left) / currentZoom;
            const y2 = (e.clientY - rect.top) / currentZoom;

            dragLinePath.setAttribute('d', `M ${x1} ${y1} L ${x2} ${y2}`);
        }

        function stopConnectionDrag() {
            isConnecting = false;
            connectionStartNodeId = null;
            dragLineLayer.style.display = 'none';
        }

        function createConnection(sourceId, targetId, existingId = null) {
            const exists = connections.find(c => 
                (c.from === sourceId && c.to === targetId) || 
                (c.from === targetId && c.to === sourceId)
            );
            if (exists) return;

            const id = existingId || 'conn-' + Math.random().toString(36).substr(2, 9);
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.classList.add('connection');
            path.id = id;
            
            path.addEventListener('click', (e) => {
                e.stopPropagation();
                selectConnection(id);
            });
            
            svgLayer.appendChild(path);
            connections.push({ id, from: sourceId, to: targetId, el: path });
            
            updateConnections();
        }

        function updateConnections() {
            connections.forEach(conn => {
                const nodeA = nodes.find(n => n.id === conn.from);
                const nodeB = nodes.find(n => n.id === conn.to);
                
                if (!nodeA || !nodeB) return;

                const wA = nodeA.el.offsetWidth;
                const hA = nodeA.el.offsetHeight;
                const wB = nodeB.el.offsetWidth;
                const hB = nodeB.el.offsetHeight;

                const x1 = nodeA.x + wA / 2;
                const y1 = nodeA.y + hA / 2;
                const x2 = nodeB.x + wB / 2;
                const y2 = nodeB.y + hB / 2;

                const midX = (x1 + x2) / 2;
                conn.el.setAttribute('d', `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`);
            });
        }
    </script>
</body>
</html>